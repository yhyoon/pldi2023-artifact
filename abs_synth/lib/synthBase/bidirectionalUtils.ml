open Common
open Vocab

open SynthLang
open Exprs
open Grammar
open GrammarUtil

(* Reference: Liang et al., Learning Minimal Abstractions, POPL'11 *)
(* Terms: *)
(* 	DSF: Domain-specific witness functions generating fresh specifications *)
(* 	DSE: Domain-specific witness functions generating existing specifications *)
(* 	Universal: Domain-agnostic witness functions generating existing specifications *)
(* Observation: DSFs sometimes waste resources by deducing unlikely subproblems. *)
(* 	e.g., +^{-1} tries to generate x + 1 + 1 + 1 + ... and eventually fails after reaching the maximum height of VSAs. *)
(* 	This happens in case of lack of component expressions. *)
(* Idea: For each DSF, maintain the probability of successfully deducing subproblems that can be eventually solved by the current set of components.*)
(* 	If a DSF fails to derive a eventually solvable subproblem, decrease the probability.*)
(* 	Otherwise, increase the probability.*)
(* 	If the probability becomes small enough, we conclude generating fresh specifications is hopeless for the operator, and turn to its DSE version *)
(* 	because DSEs only generate specs that can be satisfied the component expressions, they do not incur explorations of a long chain *)
(* Formulation: suppose F^-1 generates fresh specs. *)
(* 	F : A -> {0, 1} where A is a set of fresh specs generated by F^-1 and *)
(* 	F runs the learn procedure over them, returning 0 if a VSA is succesfully learned (otherwise 1) *)
(*  If F succeeds, the alpha (sampling probability) of ActiveCoarsen increases. *)
(* 	If F fails, the alpha decreases. *)
(* 	If the alpha becomes so small that none of a fresh spec can be sampled, switch to DSE. *)
(* 	Here, the "sampling" does not actually happen. If |fresh spec| * alpha >= 1, then use every fresh spec without actually sampling some of them. *)

(* op (string) -> float (theta) *)
let learn_rule_cache : (string, float) BatMap.t ref = ref BatMap.empty 
let euler_number = 2.71828182846
let eta = 1. 

let add_learn_rule_cache is_success op =
	let theta = try BatMap.find op !learn_rule_cache with _ -> 0. in 
	if theta <> -1000. then 
		let theta' = theta -. eta *. (1. -. (if is_success then 1. else 0.) -. (1. /. euler_number)) in 
		learn_rule_cache := BatMap.add op theta' !learn_rule_cache 	   

let is_not_fresh n_sigs op =
	(* if true then true else *)
	let theta = try BatMap.find op !learn_rule_cache with _ -> 0. in
	if theta = -1000. then true 
	else 
  	let sampling_prob = 1. /. (1. +. euler_number ** (-1. *. theta)) in 
		(* let _ = Logger.g_info_f "%s sampling prob: %.2f" op sampling_prob in   *)
  	let result = (float_of_int n_sigs) *. sampling_prob < 1. in 
  	let _ = 
  		if result then
  			(* let _ = Logger.g_info_f "freeze: %s" op in  *)
  			learn_rule_cache := BatMap.add op (-1000.) !learn_rule_cache
  	in
  	result  


let int_max = Stdlib.max_int - 1000
type state = rewrite * signature  (* production rule and abstr sig *)
type operator = string
type transition = operator * (state list) * state
type edge = (state list) * state

module StateSet = BatSet.Make(struct type t = state let compare = Stdlib.compare end)
module TransitionSet = BatSet.Make(struct type t = transition let compare = Stdlib.compare end)
module EdgeSet = BatSet.Make(struct type t = (state list) * state  let compare = Stdlib.compare end)

let nt_of_state (nt, sg) = nt
let sig_of_state (nt, sg) = sg
let create_edge states state = (states, state)

let share_prefix : string -> string -> bool
= fun str1 str2 ->
    if (String.length str1) * (String.length str2) = 0 then false
    else
        let c1 = (str1.[0]) in
        let c2 = (str2.[0]) in
        BatChar.equal c1 c2

let share_suffix str1 str2 =
    if (String.length str1) * (String.length str2) = 0 then false
    else
        let c1 = BatString.get (BatString.rev str1) 0 in
        let c2 = BatString.get (BatString.rev str2) 0 in
        BatChar.equal c1 c2


(* 
module BitSet = 
struct
	open Containers
	include CCBV
	let intset2bitset s = 
  	BatSet.fold (fun i acc -> 
  		set acc i; acc
  	) s (create ~size:32 false)
end 
let intset2bitset = BitSet.intset2bitset *)

let int_max = Stdlib.max_int - 1000

exception Covered
exception LearnDTFailure
exception LearnSinglePathFailure
exception LearnForEachFailure

(* let covered_pts spec expr desired_sig =
	try  
  	let sg = compute_signature spec expr in
  	List.fold_left (fun pts ((const, desired_const), i) -> 
  		if (Stdlib.compare const desired_const) = 0 then 
  			BatSet.add i pts 
  		else pts 
  	) BatSet.empty 
  		(BatList.combine (BatList.combine sg desired_sig) (BatList.range 0 `To ((List.length desired_sig) - 1))) 
	with UndefinedSemantics -> BatSet.empty   *)

(* 
 * in rewrite at addr, revert subtree at to_nt_addr into matching non_terminal.
 * with failure -> raise Not_found
 *)
let try_revert_to_nt_at (grammar: grammar) (to_nt_addr: addr) (addr: addr) (rewrite: rewrite): rewrite =
	let rec try_revert_expr_to_nt_at (addr: addr) (cur_expr: expr): rewrite =
		match compare_addr to_nt_addr addr with
		| ADDR_EQ -> begin
			(* try replace this expr to nt *)
			NTRewrite (reverse_product_expr grammar cur_expr)
		end
		| ADDR_L_DOM (* L_DOM: should be unreachable *)
		| ADDR_NO_ORDER ->
			ExprRewrite cur_expr
		| ADDR_R_DOM -> begin
			(* do more *)
			match cur_expr with
			| Param _ | Var _ | Const _ -> (* should be unreachable *)
				ExprRewrite cur_expr
			| Function (fun_id, sub_exprs, exprtype) -> begin
				let sub_rewrites = BatList.mapi (fun i rewrite -> try_revert_expr_to_nt_at (addr@[i]) rewrite) sub_exprs in
				normalized_func_rewrite fun_id sub_rewrites
			end
		end
	in
	let rec try_revert_rewrite_to_nt_at (addr: addr) (cur_rewrite: rewrite): rewrite =
		match compare_addr to_nt_addr addr with
		| ADDR_EQ -> begin
			(* try replace this rewrite to nt *)
			NTRewrite (reverse_product_rewrite grammar cur_rewrite)
		end
		| ADDR_L_DOM (* L_DOM: should be unreachable *)
		| ADDR_NO_ORDER ->
			cur_rewrite
		| ADDR_R_DOM -> begin
			(* do more *)
			match cur_rewrite with
			| NTRewrite _ -> cur_rewrite (* should be unreachable *)
			| ExprRewrite expr -> try_revert_expr_to_nt_at addr expr
			| FuncRewrite (fun_id, sub_rewrites) ->
				normalized_func_rewrite fun_id (BatList.mapi (fun i rewrite -> try_revert_rewrite_to_nt_at (addr@[i]) rewrite) sub_rewrites)
		end
	in
	try_revert_rewrite_to_nt_at addr rewrite

let is_feasible_by_solver (grammar: Grammar.grammar) (spec: SynthSpec.Specification.t) (rewrite: Grammar.rewrite): bool =
	let smt_string_of_addr (addr: GrammarUtil.addr): string =
		let position_prefix: string = "__p" in
		List.fold_left (^) position_prefix (List.map string_of_int addr)
	in
	(* constraint string * addr list *) 
	let rec get_structure_constraints (addr: GrammarUtil.addr) (rewrite: Grammar.rewrite): (string * GrammarUtil.addr) list =
		let expr_str_opt: string option =
			match rewrite with
			| FuncRewrite (op, sub_rewrites) ->
				let sub_addrs =
					BatList.map (fun i -> addr@[i])
						(BatList.range 0 `To ((List.length sub_rewrites) - 1))	 
				in
				Some (Printf.sprintf "(%s %s)" (Operators.op_to_string op)
					(string_of_list ~first:"" ~last:"" ~sep:" " smt_string_of_addr sub_addrs))
			| NTRewrite nt ->
				None
			| ExprRewrite (Function (op, sub_exprs, _)) ->
				let sub_addrs =
					BatList.map (fun i -> addr@[i])
						(BatList.range 0 `To ((List.length sub_exprs) - 1))	 
				in 
				Some(Printf.sprintf "(%s %s)" (Operators.op_to_string op)
					(string_of_list ~first:"" ~last:"" ~sep:" " smt_string_of_addr sub_addrs))
			| ExprRewrite expr -> Some(Exprs.string_of_expr expr)
		in
		match expr_str_opt with
		| Some expr_str -> begin
			let constraint_str =
				Printf.sprintf "(assert (= %s %s))" (smt_string_of_addr addr) expr_str
			in
			match rewrite with
			| FuncRewrite (_, sub_rewrites) ->
				List.fold_left
					(fun (i, acc) sub_rewrite ->
					let acc = acc @ (get_structure_constraints (addr@[i]) sub_rewrite) in
						(i + 1, acc)
					) (0, [(constraint_str, addr)]) sub_rewrites
				|> snd
			| ExprRewrite (Function (_, sub_exprs, _)) ->
				List.fold_left
					(fun (i, acc) sub_expr ->
					let acc = acc @ (get_structure_constraints (addr@[i]) (ExprRewrite sub_expr)) in
						(i + 1, acc)
					) (0, [(constraint_str, addr)]) sub_exprs
				|> snd
			| _ -> [(constraint_str, addr)] 
		end
		| None -> []
  	in
	let addr_tys =
    	(* addr (int list) * exprs.type BatSet.t *) 
        let rec get_addr_tys (addr: GrammarUtil.addr) (rewrite: Grammar.rewrite): (GrammarUtil.addr * Exprs.exprtype) BatSet.t =
            let ty = Grammar.ret_type_of_rewrite rewrite in 
            let rec get_addr_tys_of_expr (addr: GrammarUtil.addr) (expr: Exprs.expr): (GrammarUtil.addr * Exprs.exprtype) BatSet.t =
                match expr with
                | Function (_, sub_exprs, _) ->
                    List.fold_left
                        (fun (i, acc) sub_expr -> 
                            let acc = BatSet.union acc (get_addr_tys_of_expr (addr@[i]) sub_expr) in 
                            (i + 1, acc)
                        ) (0, (BatSet.singleton (addr, ty))) sub_exprs |> snd
                | _ -> BatSet.singleton (addr, ty)
            in
            match rewrite with
            | FuncRewrite (_, sub_rewrites) ->
                List.fold_left
                        (fun (i, acc) sub_expr -> 
                            let acc = BatSet.union acc (get_addr_tys (addr@[i]) sub_expr) in 
                            (i + 1, acc)
                        ) (0, (BatSet.singleton (addr, ty))) sub_rewrites |> snd
            | ExprRewrite expr -> get_addr_tys_of_expr addr expr
            | _ -> BatSet.singleton (addr, ty)
        in
        get_addr_tys [] rewrite
    in
	try
		(* find unsat i/o pair *)
		let _ = BatList.find (fun (input_consts, output_const) -> 
				let params =
				BatList.map (fun (i,const) -> 
						Exprs.Param (i, (Exprs.type_of_const const))
					) (zip_with_index input_consts)
				in
				(** Variable declarations *) 
				let var_decls_str =
					(* params + addrs *)
					let params_str =
					List.fold_left (fun acc param ->
							Printf.sprintf "%s\n(declare-const %s %s)"
								acc
								(Exprs.string_of_expr param)
								(Exprs.string_of_type ~z3:true (Exprs.type_of_expr param))
						) "" params
					in
					BatSet.fold (fun (addr, ty) acc ->
						Printf.sprintf "%s\n(declare-const %s %s)"
							acc
							(smt_string_of_addr addr)
							(Exprs.string_of_type ~z3:true ty)
					) addr_tys params_str
				in
				(** Input-output constraint *)
				let io_constrs: string list =
					let out_constr_str = 
					Printf.sprintf "(assert (= %s %s))" 
						(smt_string_of_addr [])
						(Exprs.string_of_const output_const)
					in
					let in_constr_strs =
					List.map (fun (param, input_const) ->
						Printf.sprintf "(assert (= %s %s))"
							(Exprs.string_of_expr param)
							(Exprs.string_of_const input_const)
					) (List.combine params input_consts)
					in
					out_constr_str :: in_constr_strs  
				in
				let structure_constr_addrs = get_structure_constraints [] rewrite in
				let structure_constrs = List.map fst structure_constr_addrs in
				let constrs = io_constrs @ structure_constrs in
				let smt_str: string =
					var_decls_str ^ "\n" ^
					(string_of_list ~first:"" ~last:"" ~sep:"\n" identity constrs)
				in
				let (q, solver) = SynthSpec.Z3interface.smt_check smt_str in
				match q with
				| UNSATISFIABLE ->
					true
				| _ ->
					false
			) (SynthSpec.Specification.to_verfiable_spec spec)
		in
		(* found unsat i/o pair -> infeasible *)
		false
	with Not_found ->
		(* all i/o pairs are sat *)
		true